# 2019年2月24日 『Rによるデータサイエンス』 Ⅱ部 6章

# 『Rによるデータサイエンス』Ⅱ部 6章
# 6章の構成
# 6-1 自己組織化マップとは
# 6-2 自己組織化マップのアルゴリズム
# 6-3 データ解析
#  6-3-1 パッケージkohonen
#   (1)関数
#   (2)ケーススタディー
#  6-3-2 パッケージsom
#   (1)関数
# 6-4 補遺と注釈

# 6章のゴール
# ・自己組織化マップの概念を理解、習得する
# ・Rで自己組織化マップを実装できるようになる


# 本章では、教師データ(外的基準、目的変数)を持たないニューラルネットワークのパターン分類方法、
# 自己組織化マップを説明する
# 自己組織化マップは比較的新しい分析方法である

# ●6-1 自己組織化マップとは

# 自己組織化マップ(SOM: Self-Organising Map)はコホネン(T. Kohonen)により提案された
# ニューラルネットワークアルゴリズムで、高次元データを2次元平面上へ非線形投射するデータ解析方法であり、
# 多次元尺度法、クラスター分析法として用いられている

# ●6-2 自己組織化マップのアルゴリズム

# 自己組織化マップの基本構造は、入力層と出力層により構成された2層のニューラルネットワークである
# 出力層は、競合層とも呼ばれている

# 入力層には分析対象となる個体j(j = 1, 2, ...,n)の変数ベクトルXj(Xj1, Xj2,...Xjp)、
# 出力層にはk(i = 1, 2, ... ,k)個のユニットmiがあるとする
# 出力層における任意の1つのユニットは、入力層における変数ベクトルとすべてリンクしている
# 初期段階では乱数により各変数との間に重みmi(mi1, mi2, ..., min)が付けられている


# ●6-3 データ解析
# ●6-3-1 パッケージkohonen

# (1)関数
# パッケージkohonenは自己組織化マップの専用パッケージである
# このパッケージには、教師データありの方法と、教師データなしの自己組織化マップに関する関数がある

# ・教師データなしの自己組織化マップの関数
# som関数
# som関数のシンタックスは以下の通り

# som(data, grid = somgrid(), rlen = 100, ...)

# dataは、解析対象となるデータセットで、ユークリッド距離計算が可能なデータマトリクス、データフレームである
# 引数gridは、somgrid関数を使って出力層の構造を指定する

# somgrid関数
# somgrid関数のシンタックス

# somgrid(xdim = 8, ydim = 6, topo = c('rectangular', 'hexagonal'))

# somgrid関数では、出力層のサイズとなる列数(xdim)と行数(ydim)、ユニットの配列方法(topo)を指定する
# ユニットの配置方法は、引数topoに'rectangular', 'hexagonal'の一つを用いる
# 'rectangular'は、ユニットを格子状に並べ、'hexagonal'は、蜂の巣状にユニットを並べる

# somの結果のリストは、summary関数、結果の図示はplot関数を使う
# plot関数には、グラフ種類を指定する引数がある


# (2)ケーススタディー
# ここではirisのクラス情報を除いて使う
# som関数を使うためには、まずsomgrid関数を使って出力層のユニットを設定する必要有
# ここでは、10列、7行のhexagonal配置法を使うことにする

install.packages('kohonen'); library('kohonen')
set.seed(10)
gr <- somgrid(topo = 'hexagonal', xdim = 10, ydim = 7)
iris.som <- som(as.matrix(iris[,1:4], gr, rlen = 200))

# som関数の実行結果iris.som$gridには、somgridで設定した10 * 7個のユニットの座標値、
# 及び出力画面の設定に関する情報が格納される

# ・ユニットの座標値は$grid$ptsに格納される
# ・各ユニットに配置される個体の特徴となるコードは、iris.som$codesに格納される
# ・使ったデータのそれぞれの個体がどのユニットに配属されるかに関する情報は、iris.som$classifに格納される

# 自己組織化マップの主な目的は、高次元のデータを2次元平面上に日線形的に射影し、
# データのパターン分類を行うことである
# パッケージkohonenでは、plot.kohonen関数をを使ってsom関数の結果を図示出来る
# plot.kohonen関数のシンタックスは以下の通り

# plot.kohonen関数
# plot.kohonen(x, type = '', lables = NULL, pchs = NULL, ...)

# 引数typeには、いくつかの図示種類があるが、ここでは2種類(codes, mapping)について紹介する
# 引数type = 'codes'にすると、用いたデータについて設定した出力画面のユニットの特徴の星グラフを表示し、
# type = 'mapping'にすると、それぞれの個体がユニットにプロットされる

plot(iris.som, type = 'codes')   # コードマップでの出力
lab.cod <- as.numeric(iris[,5])   # ラベルを数値表記に書き直す
plot(iris.som, type = 'mapping', lables = lab.cod, col = lab.cod)

# コードマップは、各ユニットに配属される個体の特徴の星グラフである
# 各ユニットの星グラフの4つの軸は、逆時計回り方向(横右、縦上、横左、縦下)にirisの4つの変数
# ガク弁の長さ(Sepal.Length)、ガク弁の幅(Sepal.Widt)、花弁の長さ(Petal.Length)、花弁の幅(Petal.width)にそれぞれ対応する


# ●6-3-2 パッケージsom

# (1)関数
# 自己組織化マップ専用パッケージとしてsomがある
# パッケージの自己組織化マップのメイン関数は、som関数である
# som関数のシンタックスは以下の通り

# som(data, xdim, ydim,...)

# dataは解析の対象となるデータセットである
# データによっては、パッケージにある標準化関数normalizeを用いて標準化する必要有
# xdim, ydimは出力画面のユニットの列数と行数である

install.packages('som'); library(som)
set.seed(80)
iris1 <- normalize(iris[,1:4])
iris.som2 <- som(iris1, xdim = 6, ydim = 5)

plot(iris.som2)

# som関数が返す各個体のデータは配属されるユニットの値であり、同じユニットに配属される固体の値は同じである
# 従って、プロットすると重なるので次のように小さい乱数を発生させ、
# それぞれのユニットにノイズを加えることで、重なりを避けることが出来る

ransu <- cbind(rnorm(nrow(iris), 0, 0.13), rnorm(nrow(iris), 0, 0.13))
out.new <- iris.som2$visual[, 1:2] + 0.5 + ransu
points(out.new[,1:2], col = c(2:4) [unclass(iris[,5])],
       pch = c(1:3) [unclass(iris[,5])])

# 次のようにout.new[, 1:2]を使うと、ユニットの特徴を表示しない散布図をが作成可能

plot(out.new[,1:2], col = c(2:4) [unclass(iris[,5])],
     pch = c(1:3) [unclass(iris[,5])])


# 結果は出力画面のユニット数に大きく依存する

# ●6-4 補遺と注釈
# パッケージclassには自己組織化マップのSOM関数が有る
# SOM関数はユニットコードを返すが、各個体がどのユニットに配属されるかに関する情報を返さない
# そこで何らかの方法で、全ての個体が出力画面のどのユニットに配属するかを判別する手続きが必要になる
# パッケージwccsomにも自己組織化マップの関数が用意されている

# 以上